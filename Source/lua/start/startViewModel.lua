---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ninovanhooff.
--- DateTime: 17/04/2022 21:24
---

import "CoreLibs/object"
import "startViewState.lua"

class("StartViewModel").extends()

local buttonTimer <const> = playdate.timer.new(1500, 0, 1) -- duration, start, end
buttonTimer.discardOnCompletion = false
buttonTimer:pause()  -- disable auto start

function StartViewModel:init()
    self.startViewState = StartViewState()
end

local pressed <const> = playdate.buttonIsPressed
local throttle <const> = playdate.kButtonA | playdate.kButtonB | playdate.kButtonUp
local buttonDown <const> = playdate.kButtonDown
local buttonLeft <const> = playdate.kButtonLeft
local buttonRight <const> = playdate.kButtonRight
local thrustSound <const> = thrust_sound
local sinThrustT <const> = sinThrustT
local cosThrustT <const> = cosThrustT

local flying = false
local planeX, planeY = 100,100
local vx,vy,planeRot,thrust = 0,0,18,0 -- thrust only 0 or 1; use thrustPower to adjust.

local function processInputs()
    -- thrust
    if (pressed(throttle)) then
        if Sounds and thrust == 0 then thrustSound:play(0) end
        thrust = 1
        if not flying then
            vx = 0
            vy = 0
        end
        flying = true
        vx = vx + cosThrustT[planeRot]*thrustPower
        vy = vy - sinThrustT[planeRot]*thrustPower
    elseif thrust == 1 then
        if Sounds then thrustSound:stop() end
        thrust = 0
    end

    -- rotation
    if pressed(buttonDown) then
        if planeRot~=18 then
            if planeRot>18 or planeRot<6 then
                planeRot = planeRot-1
            else
                planeRot = planeRot+1
            end
        end
        if planeRot<0 then planeRot = 23 end
    elseif pressed(buttonLeft) then
        if flying then
            planeRot = planeRot - 1
            if planeRot<0 then
                planeRot = 23
            end
        end
    elseif pressed(buttonRight) then
        if flying then
            planeRot = planeRot + 1
            planeRot = planeRot % 24
        end
    end
end

local function calcPlane()
    vx = vx*drag
    vy = (vy+gravity)*drag
    planeX = planeX + vx
    planeY = planeY + vy
    planeX = planeX % screenWidth
    planeY = planeY % screenHeight
end

-- returns true if this rect may collide with planePos, does not take plane sub-pos ([3] and 4]) into
-- account. When false, it is guaranteed that this rect does not intersect with the plane
local function approxRectCollision(x, y, w, h)
    -- plane size is 24px
    return planeX + 24 > x and planeX < x+w  and planeY+24 > y and planeY <y+h
end

local function calcButtonCollision()
    if approxRectCollision(200,100,100,24) then
        buttonTimer:start()
        printf("button start", buttonTimer.value, buttonTimer.currentTime)
    else
        buttonTimer:reset()
    end
end

function StartViewModel:calcTimeStep()
    processInputs()
    calcPlane()
    calcButtonCollision()
    self.startViewState.startGameProgress = buttonTimer.value
    self.startViewState.planeRot = planeRot
    self.startViewState.planeX, self.startViewState.planeY = planeX, planeY
    self.startViewState.thrust = thrust
    self.startViewState.startGameProgress = buttonTimer.value
    return self.startViewState
end
