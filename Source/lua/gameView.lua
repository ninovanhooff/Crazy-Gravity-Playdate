---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ninovanhooff.
--- DateTime: 12/03/2022 22:55
---

import "bricksView"

local playdate <const> = playdate
local gfx <const> = playdate.graphics
local geometry <const> = playdate.geometry
local polygon <const> = geometry.polygon
local setCollectsGarbage <const> = playdate.setCollectsGarbage
local boolToNum <const> = boolToNum
local floor <const> = math.floor
local min <const> = math.min
local abs <const> = math.abs
local unFlipped <const> = playdate.graphics.kImageUnflipped
local planePos <const> = planePos
local camPos <const> = camPos
local planeRotationToDeg <const> = planeRotationToDeg
local specialRenders <const> = specialRenders
local renderTooltip <const> = Tooltips.renderTooltip
local inputManager <const> = inputManager
local gameWidthTiles <const> = gameWidthTiles
local gameHeightTiles <const> = gameHeightTiles
local gameWidthPixels <const> = screenWidth
local gameHeightPixels <const> = gameHeightTiles * tileSize
local halfGameWidthPixels <const> = gameWidthPixels * 0.5
local halfGameHeightPixels <const> = gameHeightPixels * 0.5
local tileSize <const> = tileSize
local checkpointImage <const> = gfx.image.new("images/checkpoint_banner.png")
local checkpointImageW <const>, checkpointImageH <const> = checkpointImage:getSize()

local gameHUD <const> = gameHUD
local renderRoute <const> = RenderRoute

--- the active game area, excluding the HUD
local gameClipRect = playdate.geometry.rect.new(0,0, gameWidthPixels, hudY)

--- returns spent render credits
local function renderCheckpointBanner()
    local checkpoint <const> = checkpoint
    if checkpoint and checkpoint.animator then
        local scrX <const> = (checkpoint.x-camPos[1])*8-camPos[3] + checkpoint.w/2*tileSize - checkpointImageW*0.5
        local scrY <const> = (checkpoint.y-camPos[2])*8-camPos[4] + checkpoint.animator:currentValue()
        if scrX < -checkpointImageW or scrX > gameWidthPixels or scrY < -checkpointImageH or scrY > gameHeightPixels then
            return 0
        end
        gfx.setScreenClipRect(0,0, gameClipRect.width, min(scrY + 32, gameClipRect.height))
        if gameBgColor == gfx.kColorBlack then
            gfx.setImageDrawMode(gfx.kDrawModeInverted)
        end
        checkpointImage:draw(scrX, scrY)
        gfx.setImageDrawMode(gfx.kDrawModeCopy)
        gfx.setScreenClipRect(gameClipRect)
        return 4
    end

    return 0
end

local targetingArrowTipRadius <const> = 32 -- pixels
local targetingArrowBaseRadius <const> = 28 -- pixels
--- tip will point exactly at target. Base legs of triangle will be at an offset angle
local targetingArrowAngleDiffRad <const> = math.rad(5)

local function drawHomeBaseIndicator(centerX, centerY)
    local homeBase <const> = homeBase
    --- angle between plane and homeBase in radians
    local homeBaseAngleRad = math.atan(
    -- compare homeBase and planePos centers
        (homeBase.y + homeBase.h*0.5) - (planePos[2] +1.5),
        (homeBase.x + homeBase.w*0.5) - (planePos[1] +1.5)
    )

    --print("targeting homeBaseAngleRad", homeBaseAngleRad, "homeBase angle deg", math.deg(homeBaseAngleRad))

    local targetingPolygon = polygon.new(
    -- left leg
        centerX + math.cos(homeBaseAngleRad - targetingArrowAngleDiffRad)*targetingArrowBaseRadius,
        centerY + math.sin(homeBaseAngleRad - targetingArrowAngleDiffRad)*targetingArrowBaseRadius,
    -- tip
        centerX + math.cos(homeBaseAngleRad)*targetingArrowTipRadius,
        centerY + math.sin(homeBaseAngleRad)*targetingArrowTipRadius,
    -- right leg
        centerX + math.cos(homeBaseAngleRad + targetingArrowAngleDiffRad)*targetingArrowBaseRadius,
        centerY + math.sin(homeBaseAngleRad + targetingArrowAngleDiffRad)*targetingArrowBaseRadius
    )
    gfx.setColor(gameFgColor)
    gfx.drawPolygon(targetingPolygon)
end

local function drawPlaneRotationIndicator(centerX, centerY, rotationDeg)
    gfx.pushContext()
    gfx.setColor(gameFgColor)
    gfx.setLineWidth(3)

    local rotationToleranceDeg = 15*(landingTolerance.rotation)
    local rotationToleranceRadius = 20
    if rotationToleranceDeg == 0 then -- 0 would draw a full circle
        rotationToleranceDeg = 7.5
    end
    gfx.drawArc(centerX, centerY, rotationToleranceRadius, -rotationToleranceDeg, rotationToleranceDeg)

    gfx.setColor(gfx.kColorXOR)
    gfx.setLineWidth(9)
    gfx.drawArc(centerX, centerY, 20, rotationDeg-6, rotationDeg+6)

    gfx.popContext()
end

function RenderSelfRightTooltip(anchorX, anchorY)
    local buttonMappingString = inputManager:actionMappingString(Actions.SelfRight)
    local tooltip = { text= buttonMappingString .. ": " .. Actions.Labels[Actions.SelfRight] }
    renderTooltip(
        tooltip,
        anchorX or halfGameWidthPixels,
        anchorY or halfGameHeightPixels
    )
end

function RenderGame(disableHUD)
    gfx.setScreenClipRect(gameClipRect)

    local levelProps <const> = levelProps

    local renderCost = bricksView:render()
    for _,item in ipairs(specialT) do -- special blocks
        if item.x+item.w>=camPos[1] and item.x<=camPos[1]+gameWidthTiles+1 and item.y+item.h>=camPos[2] and item.y<camPos[2]+gameHeightTiles+1 then
            local scrX,scrY = (item.x-camPos[1])*8-camPos[3],(item.y-camPos[2])*8-camPos[4]
            specialRenders[item.sType-7](item, scrX, scrY)
        end
    end

    renderCost = renderCost + renderCheckpointBanner()

    -- HUD
    gfx.clearClipRect()
    if renderCost <= 80 and not disableHUD then
        -- only render HUD if we have render budget for it
        renderCost = renderCost + gameHUD:render(renderCost >= 50)
    end

    if renderCost <= 50 then
        -- Garbage Collect in frames which are not CPU-intensive
        setCollectsGarbage(true)
    else
        -- save time on GC
        setCollectsGarbage(false)
    end

    -- Draw explosion over HUD for extra dramatic effect
    if explosion then
        --explosion
        explosion:render()
        renderCost = renderCost + 6
    else
        local planeRot <const> = planeRot
        local planeX <const> = floor((planePos[1]-camPos[1])*8+planePos[3]-camPos[3])
        local planeY <const> = floor((planePos[2]-camPos[2])*8+planePos[4]-camPos[4])
        local planeCenterX <const> = planeX + 12
        local planeCenterY <const> = planeY + 12
        -- plane
        sprite:draw(
            planeX, planeY,
            unFlipped,
            planeRot%16*23, 391+(boolToNum(planeRot>15)*2-thrust)*23,
            23, 23
        )
        renderCost = renderCost + 1

        local shouldDrawPlaneRotationIndicator = #planeFreight > 0 and
            not ApproxSpecialCollision(homeBase) and
            levelProps.numBases == 1
        if landedAt and landedAt.tooltip then
            local yOffset = shouldDrawPlaneRotationIndicator and -30 or -24
            renderTooltip(landedAt.tooltip, planeCenterX, planeY + yOffset)
            renderCost = renderCost + 1
        end

        if shouldDrawPlaneRotationIndicator then
            drawHomeBaseIndicator(planeCenterX, planeCenterY) -- center of plane is at origin + 12
            renderCost = renderCost + 1
        end

        local rotationDeg = inputManager:getInputRotationDeg() or planeRotationToDeg(planeRot)
        if planePos.isCloseToPlatform then
            drawPlaneRotationIndicator(
                planeCenterX, planeCenterY,
                rotationDeg
            )
        end

        local routeProps = routeProps
        if renderCost <= 60 and
            (
                abs(planePos[1] - routeProps.lastPlaneX) > 9
                or abs(planePos[2] - routeProps.lastPlaneY) > 9
            ) then
            renderCost = renderCost + renderRoute()
        end
    end
end

--- ################
--- Game Debug View
--- ################

local dXHistory, dYHistory = {}, {}
local dxHistoryMaxLength, dyHistoryMaxLength = 60, 60
local dxHeight, dyHeight = 12, 12
local dxOrigin <const>, dyOrigin <const> = 70, 100

function RenderGameDebug()
    if collision then
        sprite:draw((planePos[1]-camPos[1])*8+planePos[3]-camPos[3], (planePos[2]-camPos[2])*8+planePos[4]-camPos[4], unFlipped, 8*23, 489, 23, 23)
    end
    --- plane collision
    local colOffX = (planePos[1]-camPos[1])*8-camPos[3]
    local colOffY = (planePos[2]-camPos[2])*8-camPos[4]
    gfx.drawLine(colOffX+colT[1],colOffY+colT[2],colOffX+colT[3],colOffY+colT[4])
    gfx.drawLine(colOffX+colT[3],colOffY+colT[4],colOffX+colT[5],colOffY+colT[6])
    gfx.drawLine(colOffX+colT[5],colOffY+colT[6],colOffX+colT[1],colOffY+colT[2])
    
    
    -- Camera debug
    local crossHairSize = 10
    -- game center crosshair
    --gfx.setDitherPattern(0.5, gfx.image.kDitherTypeDiagonalLine) -- invert alpha due to bug in SDK
    gfx.drawLine(halfGameWidthPixels - crossHairSize, halfGameHeightPixels, halfGameWidthPixels + crossHairSize, halfGameHeightPixels)
    gfx.drawLine(halfGameWidthPixels, halfGameHeightPixels - crossHairSize, halfGameWidthPixels, halfGameHeightPixels + crossHairSize)
    --gfx.setColor(gfx.kColorWhite)

    -- target crosshair
    local targetX, targetY = (TargetX or 0) + halfGameWidthPixels, (TargetY or 0) + halfGameHeightPixels
    gfx.drawLine(targetX - crossHairSize, targetY - crossHairSize, targetX + crossHairSize, targetY + crossHairSize)
    gfx.drawLine(targetX - crossHairSize, targetY + crossHairSize, targetX + crossHairSize, targetY - crossHairSize)
    
    
    if dX then
        table.insert(dXHistory, dX)
    end

    if #dXHistory > dxHistoryMaxLength then
        table.remove(dXHistory, 1)
    end

    if dY then
        table.insert(dYHistory, dY)
    end

    if #dYHistory > dyHistoryMaxLength then
        table.remove(dYHistory, 1)
    end

    -- render dx graph
    for i, item in ipairs(dXHistory) do
        gfx.drawPixel(dxOrigin + i, dxOrigin - item)
    end

    local oldDrawMode = gfx.getImageDrawMode()

    gfx.drawText("dX", dxOrigin - 25, dxOrigin)
    gfx.drawText("dY", dyOrigin - 25, dyOrigin)
    gfx.setImageDrawMode(oldDrawMode) --text color
    gfx.drawLine(dxOrigin, dxOrigin, dxOrigin + dxHistoryMaxLength, dxOrigin)
    gfx.drawLine(dxOrigin, dxOrigin - dxHeight, dxOrigin, dxOrigin + dxHeight)

    -- render dy graph
    for i, item in ipairs(dYHistory) do
        gfx.drawPixel(dyOrigin + i, dyOrigin + item)
    end

    gfx.drawLine(dyOrigin, dyOrigin, dyOrigin + dyHistoryMaxLength, dyOrigin)
    gfx.drawLine(dyOrigin, dyOrigin - dyHeight, dyOrigin, dyOrigin + dyHeight)
end
