---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ninovanhooff.
--- DateTime: 29/04/2022 11:20
---

local playdate <const> = playdate
local keyRepeatTimer <const> = playdate.timer.keyRepeatTimer
local getCrankTicks <const> = playdate.getCrankTicks
local pressed <const> = playdate.buttonIsPressed
local justPressed <const> = playdate.buttonJustPressed
local justReleased <const> = playdate.buttonJustReleased
local buttonDown <const> = playdate.kButtonDown
local buttonUp <const> = playdate.kButtonUp
local buttonLeft <const> = playdate.kButtonLeft
local buttonRight <const> = playdate.kButtonRight
local buttonA <const> = playdate.kButtonA
local buttonB <const> = playdate.kButtonB
local resourceLoader <const> = GetResourceLoader()
local scrollUpSound <const> = resourceLoader:getSound("sounds/ui_scroll_down.wav")
local scrollDownSound <const> = resourceLoader:getSound("sounds/ui_scroll_up.wav")
local scrollDenialSound <const> = resourceLoader:getSound("sounds/ui_scroll_denial.wav")

local sign <const> = sign
local clamp <const> = clamp
local abs <const> = math.abs
local ceil <const> = math.ceil

local numChallenges <const> = numChallenges
local levelNames <const> = levelNames

class("LevelSelectViewModel").extends()

function LevelSelectViewModel:init()
    LevelSelectViewModel.super.init(self)
    self.lastUnlocked = numLevelsUnlocked()
    --- the level for which an unlock animation should be played
    self.newUnlock = nil
    self.menuOptions = {}
    for i = 1,numLevels do
        self.menuOptions[i] = {
            title = levelNames[i],
            challenges = getChallengesForPath(levelPath(i)),
            levelNumber = i,
            -- scores added on resume
        }
    end
    self.listOffset = 0 -- vertical position, for bumper effect
    self.selectedIdx = numLevelsUnlocked()
    self.selectedChallengeIdx = firstUnCompletedChallenge(self.selectedIdx) or 1
    self.dPadImageIdx = 1
    self.aButtonImageIdx = 1
    self.keyTimer = nil
    self.keyTimerRemover = self:createKeyTimerRemover()
end

function LevelSelectViewModel:createKeyTimerRemover()
    return function()
        if self.keyTimer then
            self.keyTimer:remove()
            self.keyTimer = nil
        end
    end
end

function LevelSelectViewModel:startVideo(path)
    if self.videoViewModel then
        self.videoViewModel:destroy()
    end
    if not playdate.file.exists(path .. ".pdv") then
        print("ERR could not load video")
        return
    end
    self.videoViewModel = VideoViewModel(path, true)
    self.videoPlayerView = VideoPlayerView(self.videoViewModel)
    self.videoViewModel.offsetX = 217
    self.videoViewModel.offsetY = 37
    self.videoPlayerView:resume()
end

function LevelSelectViewModel:resume()
    if self.shouldUpdateSelectionOnResume then
        self.selectedIdx = currentLevel
        self.shouldUpdateSelectionOnResume = false
    end

    local numLevelsUnlocked = numLevelsUnlocked()
    if self.lastUnlocked ~= numLevelsUnlocked then
        self.lastUnlocked = numLevelsUnlocked
        self.newUnlock = numLevelsUnlocked
    end

    --- the row index for which the View should start a ShakeAndDenied animation.
    --- reset to nil by View when handled
    self.deniedUnlock = nil

    for i = 1,numLevels do
        local curOptions = self.menuOptions[i]
        local rawScores = records[i]
        local achievements = {}
        if rawScores then
            -- formatting for display
            curOptions.scores = {
                ceil(rawScores[1]),
                ceil(rawScores[2]),
                rawScores[3]
            }
            for j, score in ipairs(rawScores) do
                achievements[j] = score <= curOptions.challenges[j]
            end
        end
        curOptions.achievements = achievements
        curOptions.unlocked = Debug or numLevelsUnlocked >= i
    end
    --- when pressing the A button to dismiss a gameOverScreen, we don't want to register that press
    --- here again to start a level
    self.aButtonPressedAtLeastOnce = false
    require("lua/video-player/VideoPlayerScreen")
    self:startVideo(levelPath(self.selectedIdx))
end

function LevelSelectViewModel:pause()
    self.newUnlock = nil
    self:keyTimerRemover()
end

function LevelSelectViewModel:gameWillPause()
    self:keyTimerRemover()
end

function LevelSelectViewModel:destroy()
    self:pause()
    if self.videoViewModel then
        self.videoViewModel:destroy()
    end
end

function LevelSelectViewModel:moveSelection(offset)
    if offset == 0 then return end

    local oldSelectedIdx = self.selectedIdx
    self.selectedIdx = clamp(oldSelectedIdx + offset, 1, #self.menuOptions)
    --self.selectedChallengeIdx = firstUnCompletedChallenge(self.selectedIdx) or 1

    local changeSign = sign(self.selectedIdx - oldSelectedIdx)
    if changeSign == 1 then
        scrollDownSound:play()
    elseif changeSign == 0 then
        scrollDenialSound:play()
        if self.selectedIdx == 1 then
            self.listOffset = 4
        elseif self.selectedIdx == #self.menuOptions then
            self.listOffset = -4
        end
    elseif changeSign == -1 then
        scrollUpSound:play()
    end

    self:startVideo(levelPath(self.selectedIdx))
end

--- returns true when finished
function LevelSelectViewModel:update()
    -- clear bmpers by overdraw
    if abs(self.listOffset) > 1 then
        self.listOffset = self.listOffset/2
    else
        self.listOffset = 0
    end

    if self.videoViewModel then
        self.videoViewModel:update()
    end

    self:moveSelection(getCrankTicks(5))

    if justPressed(buttonDown) then
        local function timerCallback()
            self:moveSelection(1)
        end
        self.keyTimerRemover()
        self.keyTimer = keyRepeatTimer(timerCallback)
    elseif justPressed(buttonUp) then
        local function timerCallback()
            self:moveSelection(-1)
        end
        self.keyTimerRemover()
        self.keyTimer = keyRepeatTimer(timerCallback)
    elseif justReleased(buttonDown | buttonUp) then
        self:keyTimerRemover()
    elseif justPressed(buttonLeft) then
        self.selectedChallengeIdx = clamp(self.selectedChallengeIdx -1, 1, numChallenges)
    elseif justPressed(buttonRight) then
        self.selectedChallengeIdx = clamp(self.selectedChallengeIdx +1, 1, numChallenges)
    elseif justPressed(buttonA) then
        self.aButtonPressedAtLeastOnce = true
    elseif justReleased(buttonA) and self.aButtonPressedAtLeastOnce then
        currentLevel = self.selectedIdx
        require("lua/gameScreen")

        if self.selectedIdx == 1 then
            -- start orientation video
            ui_confirm:play()
            require "lua/video-player/VideoPlayerScreen"
            pushScreen(VideoPlayerScreen(
                "video/orientation",
                function()
                    self.shouldUpdateSelectionOnResume = true
                    return GameScreen(currentLevel, self.selectedChallengeIdx)
                end
            ))
        elseif numLevelsUnlocked() >= self.selectedIdx or Debug then
            ui_confirm:play()
            self.shouldUpdateSelectionOnResume = true
            pushScreen(
                GameScreen(currentLevel, self.selectedChallengeIdx)
            )
        else
            self.deniedUnlock = self.selectedIdx
        end
    elseif justPressed(buttonB) then
        ui_cancel:play()
        popScreen()
    end

    -- button state images
    self.aButtonImageIdx = pressed(buttonA) and 2 or 1
    self.dPadImageIdx =
        pressed(buttonLeft) and 2 or
        pressed(buttonRight) and 3 or
        pressed(buttonUp) and 4 or
        pressed(buttonDown) and 5 or
        1 -- neutral
end

function LevelSelectViewModel:selectedOption()
    return self.menuOptions[self.selectedIdx]
end
