---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ninovanhooff.
--- DateTime: 29/04/2022 11:20
---

local numChallenges <const> = numChallenges
local levelNames <const> = levelNames
local keyRepeatTimer <const> = playdate.timer.keyRepeatTimer
local pressed <const> = playdate.buttonIsPressed
local justPressed <const> = playdate.buttonJustPressed
local justReleased <const> = playdate.buttonJustReleased
local buttonDown <const> = playdate.kButtonDown
local buttonUp <const> = playdate.kButtonUp
local buttonLeft <const> = playdate.kButtonLeft
local buttonRight <const> = playdate.kButtonRight
local buttonA <const> = playdate.kButtonA
local buttonB <const> = playdate.kButtonB

local clamp <const> = clamp
local ceil <const> = math.ceil

class("LevelSelectViewModel").extends()

function LevelSelectViewModel:init()
    LevelSelectViewModel.super.init(self)
    self.lastUnlocked = numLevelsUnlocked()
    --- the level for which an unlock animation should be played
    self.newUnlock = nil
    self.menuOptions = {}
    for i = 1,numLevels do
        self.menuOptions[i] = {
            title = levelNames[i],
            challenges = getChallengesForPath(levelPath(i)),
            levelNumber = i,
            -- scores added on resume
        }
    end
    self.selectedIdx = numLevelsUnlocked()
    self.selectedChallengeIdx = firstUnCompletedChallenge(self.selectedIdx) or 1
    self.dPadImageIdx = 1
    self.aButtonImageIdx = 1
    self.keyTimer = nil
    self.keyTimerRemover = self:createKeyTimerRemover()
end

function LevelSelectViewModel:createKeyTimerRemover()
    return function()
        if self.keyTimer then
            self.keyTimer:remove()
            self.keyTimer = nil
        end
    end
end

function LevelSelectViewModel:startVideo(path)
    if self.videoViewModel then
        self.videoViewModel:destroy()
    end
    if not playdate.file.exists(path .. ".pdv") then
        print("ERR could not load video")
        return
    end
    self.videoViewModel = VideoViewModel(path, true)
    self.videoPlayerView = VideoPlayerView(self.videoViewModel)
    self.videoViewModel.offsetX = 217
    self.videoViewModel.offsetY = 37
    self.videoPlayerView:resume()
end

function LevelSelectViewModel:resume()
    local numLevelsUnlocked = numLevelsUnlocked()
    if self.lastUnlocked ~= numLevelsUnlocked then
        self.lastUnlocked = numLevelsUnlocked
        self.newUnlock = numLevelsUnlocked
    end

    --- the row index for which the View should start a ShakeAndDenied animation.
    --- reset to nil by View when handled
    self.deniedUnlock = nil

    for i = 1,numLevels do
        local curOptions = self.menuOptions[i]
        local rawScores = records[i]
        local achievements = {}
        if rawScores then
            -- formatting for display
            curOptions.scores = {
                ceil(rawScores[1]),
                ceil(rawScores[2]),
                rawScores[3]
            }
            for j, score in ipairs(rawScores) do
                achievements[j] = score <= curOptions.challenges[j]
            end
        end
        curOptions.achievements = achievements
        curOptions.unlocked = Debug or numLevelsUnlocked >= i
    end
    --- when pressing the A button to dismiss a gameOverScreen, we don't want to register that press
    --- here again to start a level
    self.aButtonPressedAtLeastOnce = false
    require("lua/video-player/VideoPlayerScreen")
    self:startVideo(levelPath(self.selectedIdx))
end

function LevelSelectViewModel:pause()
    self.newUnlock = nil
    self:keyTimerRemover()
end

function LevelSelectViewModel:gameWillPause()
    self:keyTimerRemover()
end

function LevelSelectViewModel:destroy()
    self:pause()
    if self.videoViewModel then
        self.videoViewModel:destroy()
    end
end

function LevelSelectViewModel:moveSelection(offset)
    self.selectedIdx = clamp(self.selectedIdx + offset, 1, #self.menuOptions)
    --self.selectedChallengeIdx = firstUnCompletedChallenge(self.selectedIdx) or 1
    self:startVideo(levelPath(self.selectedIdx))
end

--- returns true when finished
function LevelSelectViewModel:update()
    if self.videoViewModel then
        self.videoViewModel:update()
    end
    if justPressed(buttonDown) then
        local function timerCallback()
            self:moveSelection(1)
        end
        self.keyTimerRemover()
        self.keyTimer = keyRepeatTimer(timerCallback)
    elseif justPressed(buttonUp) then
        local function timerCallback()
            self:moveSelection(-1)
        end
        self.keyTimerRemover()
        self.keyTimer = keyRepeatTimer(timerCallback)
    elseif justReleased(buttonDown | buttonUp) then
        self:keyTimerRemover()
    elseif justPressed(buttonLeft) then
        self.selectedChallengeIdx = clamp(self.selectedChallengeIdx -1, 1, numChallenges)
    elseif justPressed(buttonRight) then
        self.selectedChallengeIdx = clamp(self.selectedChallengeIdx +1, 1, numChallenges)
    elseif justPressed(buttonA) then
        self.aButtonPressedAtLeastOnce = true
    elseif justReleased(buttonA) and self.aButtonPressedAtLeastOnce then
        currentLevel = self.selectedIdx
        require("lua/gameScreen")

        if self.selectedIdx == 1 then
            -- start orientation video
            ui_confirm:play()
            require "lua/video-player/VideoPlayerScreen"
            pushScreen(VideoPlayerScreen(
                "video/orientation",
                function()
                    return GameScreen(currentLevel, self.selectedChallengeIdx)
                end
            ))
        elseif numLevelsUnlocked() >= self.selectedIdx or Debug then
            ui_confirm:play()
            pushScreen(
                GameScreen(currentLevel, self.selectedChallengeIdx)
            )
        else
            self.deniedUnlock = self.selectedIdx
        end
    elseif justPressed(buttonB) then
        ui_cancel:play()
        popScreen()
    end

    -- button state images
    self.aButtonImageIdx = pressed(buttonA) and 2 or 1
    self.dPadImageIdx =
        pressed(buttonLeft) and 2 or
        pressed(buttonRight) and 3 or
        pressed(buttonUp) and 4 or
        pressed(buttonDown) and 5 or
        1 -- neutral
end

function LevelSelectViewModel:selectedOption()
    return self.menuOptions[self.selectedIdx]
end
