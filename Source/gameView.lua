---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ninovanhooff.
--- DateTime: 12/03/2022 22:55
---

local gfx = playdate.graphics

hudY = 224
hudBGClr = gfx.kColorWhite
interfaceBoxBgClr = gfx.kColorBlack
interfaceBoxUpperClr = interfaceBoxBgClr --todo dotted line or something
interfaceBoxLowerClr = interfaceBoxUpperClr

function drawInterfaceBox(x,w)
    pgeDrawLine(x,hudY+1,x+w,hudY+1,interfaceBoxUpperClr)
    pgeDrawLine(x,hudY+1,x,hudY+14,interfaceBoxUpperClr)
    pgeDrawLine(x+w,hudY+2,x+w,hudY+14,interfaceBoxLowerClr)
    pgeDrawLine(x+1,hudY+14,x+w,hudY+14,interfaceBoxLowerClr)
    pgeDrawRect(x+1,hudY+2,w-1,13,interfaceBoxBgClr)
end

function RenderHUD()
    gfx.setColor(hudBGClr)
    gfx.fillRect(0,hudY,400,16)
    pgeDraw(1,hudY+1,28,14,232,314,28,14) -- remain freight stat
    drawInterfaceBox(30,106)
    local freightPosCount = 0
    for i,item in ipairs(remainingFreight) do
        for j=0,math.min(item-1,7) do
            pgeDraw(32+freightPosCount*13,hudY+3,12,12,64+i*16,346,16,16)
            freightPosCount = freightPosCount + 1
        end
    end

    local planeFreightX = 147
    pgeDraw(planeFreightX,hudY+1,28,14,260,314,28,14) -- planeFreight stat
    drawInterfaceBox(planeFreightX+29,14*extras[3])
    for i,item in ipairs(planeFreight) do
        pgeDraw(planeFreightX+31+(i-1)*13,hudY+3,12,12,80+item[1]*16,346,16,16)
    end

    local keysX = 220
    pgeDraw(keysX,hudY+1,28,14,344,314,28,14) -- keys
    drawInterfaceBox(keysX+30,50)
    for i=1,4 do
        if keys[i] then
            pgeDraw(keysX+32+(i-1)*12,hudY+3,12,12,185+(frameCounter % 7)*16,414+(i-1)*16,16,16)
        end
    end

    local fuelX = 300
    pgeDraw(fuelX+2,hudY+1,28,14,316,314,28,14) -- fuel stat
    drawInterfaceBox(fuelX+32,48)
    local fuelW = math.ceil(44*fuel/6000/4)*4 -- todo was round
    pgeDraw(fuelX+34,hudY+4,fuelW,9,231,328,fuelW,9)

    for i=0,extras[2]-1 do -- lives
        pgeDraw(5+i*25,5,23,23,46,414,23,23,0,180)
    end

    drawInterfaceBox(382,75) -- Time
    --gfx.setImageDrawMode()
    pgeDrawText(384,hudY+4,green,TimeString(frameCounter*0.05).."/"..lMin..":"..lSec)

    local warnX = 460

    if math.abs(vx) > landingTolerance[1] or vy > landingTolerance[2] then --red
        pgeDraw(warnX,hudY,16,16,165,461,16,16)
    elseif math.abs(vx) > landingTolerance[1]-1 or vy > landingTolerance[2] - 1 then --yellow
        pgeDraw(warnX,hudY,16,16,149,461,16,16)
    else -- green
        pgeDraw(warnX,hudY,16,16,133,461,16,16)
    end
end

function RenderLineVert(maxJ) -- render column bricks, brute force, fail safe
    local i=camPos[1]
    local j = camPos[2]
    while j<= maxJ do
        local curBrick = brickT[i][j]
        if curBrick[1]>2 then
            if curBrick[1]>=7 then --concrete
                pgeDraw((i-camPos[1])*8-camPos[3],(j-camPos[2])*8-camPos[4],8*(curBrick[3]-curBrick[4]),8*(curBrick[3]-curBrick[5]),240+(curBrick[2]*curBrick[3]+curBrick[4])*8,greySumT[curBrick[3]]+curBrick[5]*8,8*(curBrick[3]-curBrick[4]),8*(curBrick[3]-curBrick[5]),0,255)
            elseif curBrick[1]>=3 then --color
                pgeDraw((i-camPos[1])*8-camPos[3],(j-camPos[2])*8-camPos[4],(curBrick[2]-curBrick[4])*8,(curBrick[3]-curBrick[5])*8,(curBrick[1]-3)*48+sumT[curBrick[2]]+curBrick[4]*8,sumT[curBrick[3]]+curBrick[5]*8,(curBrick[2]-curBrick[4])*8,(curBrick[3]-curBrick[5])*8,0,255)
            end
        end
        j = j + curBrick[3]-curBrick[5]
        curBrick = nil
    end
end

function RenderLineHoriz(maxI) -- render row  bricks, brute force, fail safe
    i=camPos[1]
    j = camPos[2]
    while i<=maxI do
        printf("indexing brickT", i, j)
        curBrick = brickT[i][j]
        if curBrick[1]>2 then
            if curBrick[1]>=7 then --concrete
                pgeDraw((i-camPos[1])*8-camPos[3],(j-camPos[2])*8-camPos[4],8*(curBrick[3]-curBrick[4]),8*(curBrick[3]-curBrick[5]),240+curBrick[2]*curBrick[3]*8,greySumT[curBrick[3]]+curBrick[5]*8,8*(curBrick[3]-curBrick[4]),8*(curBrick[3]-curBrick[5]),0,255)
                i = i + curBrick[3]-curBrick[4]
            elseif curBrick[1]>=3 then --color
                pgeDraw((i-camPos[1])*8-camPos[3],(j-camPos[2])*8-camPos[4],(curBrick[2]-curBrick[4])*8,(curBrick[3]-curBrick[5])*8,(curBrick[1]-3)*48+sumT[curBrick[2]]+curBrick[4]*8,sumT[curBrick[3]]+curBrick[5]*8,(curBrick[2]-curBrick[4])*8,(curBrick[3]-curBrick[5])*8,0,255)
                i = i + curBrick[2]-curBrick[4]
            end
        else
            i = i + curBrick[2]-curBrick[4]
        end

    end
end

function RenderBackground()
    gfx.setDitherPattern(0.81, gfx.image.kDitherTypeBayer8x8)
    gfx.fillRect(0,0,400,240)

    local bgTileSize = 32
    local bgOffX = math.floor(((camPos[1]*8+camPos[3]) % 128)*0.25)
    local bgOffY = math.floor(((camPos[2]*8+camPos[4]) % 128)*0.25)
    for i=0,math.ceil(screenWidth/bgTileSize) do
        for j = 0,math.ceil(hudY/bgTileSize) do
            pgeDraw(i*bgTileSize-bgOffX,j*bgTileSize-bgOffY,bgTileSize,bgTileSize,levelProps.bg*bgTileSize,60,bgTileSize,bgTileSize,0,255)
        end
    end
end

function RenderGame()
    RenderBackground()

    sprite:setInverted(false)
    gfx.setColor(gfx.kColorBlack)

    for i,item in ipairs(specialT) do -- special blocks
        scrX,scrY = (item.x-camPos[1])*8-camPos[3],(item.y-camPos[2])*8-camPos[4]
        if item.x+item.w>=camPos[1] and item.x<=camPos[1]+61 and item.y+item.h>=camPos[2] and item.y<camPos[2]+33 then
            specialRenders[item.sType-7](item)
        end
    end

    maxI=camPos[1]+screenWidthTiles -- need to draw one column extra because of scrolling
    maxJ=camPos[2]+screenHeightTiles -- no need to draw offscreen, world partially covered by HUD

    RenderLineHoriz(maxI)
    RenderLineVert(maxJ)

    local i = camPos[1]+1
    while i<=maxI do -- bricks
        local j = camPos[2]+1
        while j<=maxJ do
            local curBrick = brickT[i][j]
            if not curBrick then printf("curBrick",i,j,camPos[1],camPos[2]) end
            --if curBrick[1]~=0 then printf(curBrick[2],curBrick[3],curBrick[4],curBrick[5]) end
            if curBrick[1]>2 and curBrick[4]==0 and curBrick[5]==0 then
                if curBrick[1]<7 then --colors
                    pgeDraw((i-camPos[1])*8-camPos[3],(j-camPos[2])*8-camPos[4],curBrick[2]*8,curBrick[3]*8,(curBrick[1]-3)*48+sumT[curBrick[2]],sumT[curBrick[3]],curBrick[2]*8,curBrick[3]*8,0,255)
                    --printf("color:",(i-camPos[1])*8,(j-camPos[2])*8,curBrick[2]*8,curBrick[3]*8,(curBrick[1]-3)*48+sumT[curBrick[2]],sumT[curBrick[3]],curBrick[2]*8,curBrick[3]*8)
                else -- concrete
                    pgeDraw((i-camPos[1])*8-camPos[3],(j-camPos[2])*8-camPos[4],8*curBrick[3],8*curBrick[3],240+curBrick[2]*curBrick[3]*8,greySumT[curBrick[3]],curBrick[3]*8,curBrick[3]*8,0,255)
                end
            end
            j = j + curBrick[3]-curBrick[5]
            curBrick = nil
        end
        i = i + 1
    end

    pgeDraw((planePos[1]-camPos[1])*8+planePos[3]-camPos[3],(planePos[2]-camPos[2])*8+planePos[4]-camPos[4],23,23,planeRot%16*23,391+(boolToNum(planeRot>15)*2-thrust)*23,23,23) -- plane

    --explosion
    if collision and not Debug then
        pgeDraw((planePos[1]-camPos[1])*8+planePos[3]-camPos[3]+explodeX,(planePos[2]-camPos[2])*8+planePos[4]-camPos[4]+explodeY,23,23,explodeJ*23,489,23,23)
    end

    RenderHUD()

end
