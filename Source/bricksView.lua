---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ninovanhooff.
--- DateTime: 28/03/2022 22:53
---

import "CoreLibs/object"

local gfx <const> = playdate.graphics
local noFlip <const> = gfx.kImageUnflipped


class('BricksView').extends()

function BricksView:init()
    BricksView.super.init()
    self.bufferWidthTiles = gameWidthTiles + 1
    self.bufferHeightTiles = gameHeightTiles + 1
    self.activeBuffer = gfx.image.new(self.bufferWidthTiles * tileSize, self.bufferHeightTiles* tileSize)
    self.inactiveBuffer = self.activeBuffer:copy()
    gfx.lockFocus(self.activeBuffer)
        self:initBricks()
    gfx.unlockFocus()
end

function BricksView:render()
    local shiftX, shiftY = camPos[1] - self.camPosX, camPos[2] - self.camPosY
    if shiftX ~= 0 or shiftY ~=0 then
        printf("Render", frameCounter, camPos[1],self.camPosX, shiftX, camPos[2], self.camPosY, shiftY, math.abs(shiftX)+math.abs(shiftY))
        self.inactiveBuffer:clear(gfx.kColorClear)
        gfx.lockFocus(self.inactiveBuffer)
            self.activeBuffer:draw(-shiftX*tileSize, -shiftY*tileSize)
            if shiftX < 0 then
                for x = 0, -shiftX, 1 do
                    self:renderLineVert(camPos[1]+x, camPos[2], x*tileSize)
                end
            elseif shiftX > 0 then
                for x = 0, shiftX, 1 do
                    self:renderLineVert(self.camPosX+self.bufferWidthTiles + x, camPos[2], (self.bufferWidthTiles - shiftX+x) * tileSize)
                end
            end
            if shiftY < 0 then
                for y = 0, -shiftY, 1 do
                    self:renderLineHoriz(camPos[1], camPos[2]+y, y*tileSize)
                end
            elseif shiftY > 0 then
                for y = 0, shiftY, 1 do
                    self:renderLineHoriz(camPos[1], self.camPosY+self.bufferHeightTiles + y, (self.bufferHeightTiles-shiftY+y) * tileSize)
                end
            end
        gfx.unlockFocus()
        self.activeBuffer, self.inactiveBuffer = self.inactiveBuffer, self.activeBuffer
    end

    self.camPosX = camPos[1]
    self.camPosY = camPos[2]
    self.activeBuffer:draw(-camPos[3], -camPos[4])
end

function BricksView:initBricks()
    local startJ = camPos[2]
    local maxJ=camPos[2]+ self.bufferHeightTiles-1
    local i = camPos[1]
    local j = camPos[2]

    while j<=maxJ do -- bricks
        self:renderLineHoriz(i,j, (j-startJ)*tileSize)
        j = j + 1
    end

    self.camPosX = camPos[1]
    self.camPosY = camPos[2]
end

--- render column bricks, brute force, fail safe
--- Starts drawing at 1,1 so use a drawOffset to position the result
function BricksView:renderLineVert(i,j, drawOffsetX)
    local startJ = j
    while j<= startJ + self.bufferHeightTiles do
        local curBrick = brickT[i]
        if not curBrick then
            break
        end
        curBrick = curBrick[j]

        if curBrick[1]>2 then
            if curBrick[1]>=7 then --concrete
                sprite:draw(
                        drawOffsetX, (j-startJ)*8,
                        noFlip,
                        240+(curBrick[2]*curBrick[3]+curBrick[4])*8,
                        greySumT[curBrick[3]]+curBrick[5]*8,
                        8*(curBrick[3]-curBrick[4]),
                        8*(curBrick[3]-curBrick[5])
                )
            elseif curBrick[1]>=3 then --color
                sprite:draw(
                        drawOffsetX, (j-startJ)*8,
                        noFlip,
                        (curBrick[1]-3)*48+sumT[curBrick[2]]+curBrick[4]*8,
                        sumT[curBrick[3]]+curBrick[5]*8,
                        (curBrick[2]-curBrick[4])*8,
                        (curBrick[3]-curBrick[5])*8
                )
            end
        end
        j = j + curBrick[3]-curBrick[5]
        curBrick = nil
    end
end

--- render a row of bricks, brute force, fail safe
function BricksView:renderLineHoriz(i,j, drawOffsetY)
    local startI = i
    while i<=startI+self.bufferWidthTiles do
        local curBrick = brickT[i]
        if not curBrick then
            break
        end
        curBrick = curBrick[j]

        if curBrick[1]>2 then
            if curBrick[1]>=7 then --concrete
                sprite:draw(
                        (i -startI) * 8, drawOffsetY,
                        noFlip,
                        240+curBrick[2]*curBrick[3]*8,
                        greySumT[curBrick[3]]+curBrick[5]*8,
                        8*(curBrick[3]-curBrick[4]),
                        8*(curBrick[3]-curBrick[5])
                )
                i = i + curBrick[3]-curBrick[4]
            elseif curBrick[1]>=3 then --color
                sprite:draw(
                        (i -startI) * 8, drawOffsetY,
                        noFlip,
                        (curBrick[1]-3)*48+sumT[curBrick[2]]+curBrick[4]*8,
                        sumT[curBrick[3]]+curBrick[5]*8,
                        (curBrick[2]-curBrick[4])*8,
                        (curBrick[3]-curBrick[5])*8
                )
                i = i + curBrick[2]-curBrick[4]
            end
        else
            i = i + curBrick[2]-curBrick[4]
        end

    end
end
