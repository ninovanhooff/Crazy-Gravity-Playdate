---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ninovanhooff.
--- DateTime: 11/03/2022 16:29
---

import "util.lua"

local file = playdate.file

sumT = {0,8,24}
greySumT = {-1,56,32,0} -- -1:unused
greyMaxT = {-1,9,8,5}


function LoadFile(cgpbPath)
    printf("loading ".. cgpbPath)
    local jsonPath = stripExtension(cgpbPath) .. ".json"
    if not file.exists(cgpbPath) then
        printf("File does not exist: " .. cgpbPath)
    end
    if not file.exists(jsonPath) then
        printf("File does not exist: " .. jsonPath)
    end

    brickT = nil
    specialT = nil
    levelProps = nil

    local jsonFile, err = file.open(jsonPath)
    local levelData = json.decodeFile(jsonFile)
    specialT = levelData["specialT"]
    levelProps = levelData["levelProps"]
    levelProps.lives = levelProps.lives or 5
    levelData = nil
    jsonFile:close()

    TFile = file.open(cgpbPath, playdate.file.kFileRead)
    if not TFile then
        error("Error opening file ".. cgpbPath)
    end
    local id = TFile:read(4)
    if id~="CGPB" then
        TFile:close()
        error("filetype",id)
    end
    TFile:read(1) --nl

    brickT = {}
    for i = 1,levelProps.sizeX do
        brickT[i]={}
        local curColStr = TFile:readline()
        for j=1,levelProps.sizeY do
            local n = (j-1)*5
            local tile = {curColStr:byte(n+1,n+5)}
            for k,ktem in ipairs(tile) do
                tile[k] = ktem-48
            end
            brickT[i][j] = tile
            --tile[1],tile[2],tile[3],tile[4],tile[5] = nil,nil,nil,nil,nil
            tile = nil
        end

        if  i%(math.floor(1000/levelProps.sizeY))== 2  then
            print("Loading...",i/levelProps.sizeX)
        end
        curColStr = nil
    end
    TFile:close()
    TFile = nil
    printf("loaded dim",#brickT,#brickT[1])
    return true
end

function RenderLineVert(maxJ) -- render column bricks, brute force, fail safe
    local i=camPos[1]
    local j = camPos[2]
    while j<= maxJ do
        local curBrick = brickT[i][j]
        if curBrick[1]>2 then
            if curBrick[1]>=7 then --concrete
                pgeDraw((i-camPos[1])*8-camPos[3],(j-camPos[2])*8-camPos[4],8*(curBrick[3]-curBrick[4]),8*(curBrick[3]-curBrick[5]),240+(curBrick[2]*curBrick[3]+curBrick[4])*8,greySumT[curBrick[3]]+curBrick[5]*8,8*(curBrick[3]-curBrick[4]),8*(curBrick[3]-curBrick[5]),0,255)
            elseif curBrick[1]>=3 then --color
                pgeDraw((i-camPos[1])*8-camPos[3],(j-camPos[2])*8-camPos[4],(curBrick[2]-curBrick[4])*8,(curBrick[3]-curBrick[5])*8,(curBrick[1]-3)*48+sumT[curBrick[2]]+curBrick[4]*8,sumT[curBrick[3]]+curBrick[5]*8,(curBrick[2]-curBrick[4])*8,(curBrick[3]-curBrick[5])*8,0,255)
            end
        end
        j = j + curBrick[3]-curBrick[5]
        curBrick = nil
    end
end

function RenderLineHoriz(maxI) -- render row  bricks, brute force, fail safe
    i=camPos[1]
    j = camPos[2]
    while i<=maxI do
        curBrick = brickT[i][j]
        if curBrick[1]>2 then
            if curBrick[1]>=7 then --concrete
                pgeDraw((i-camPos[1])*8-camPos[3],(j-camPos[2])*8-camPos[4],8*(curBrick[3]-curBrick[4]),8*(curBrick[3]-curBrick[5]),240+curBrick[2]*curBrick[3]*8,greySumT[curBrick[3]]+curBrick[5]*8,8*(curBrick[3]-curBrick[4]),8*(curBrick[3]-curBrick[5]),0,255)
                i = i + curBrick[3]-curBrick[4]
            elseif curBrick[1]>=3 then --color
                pgeDraw((i-camPos[1])*8-camPos[3],(j-camPos[2])*8-camPos[4],(curBrick[2]-curBrick[4])*8,(curBrick[3]-curBrick[5])*8,(curBrick[1]-3)*48+sumT[curBrick[2]]+curBrick[4]*8,sumT[curBrick[3]]+curBrick[5]*8,(curBrick[2]-curBrick[4])*8,(curBrick[3]-curBrick[5])*8,0,255)
                i = i + curBrick[2]-curBrick[4]
            end
        else
            i = i + curBrick[2]-curBrick[4]
        end

    end
end
